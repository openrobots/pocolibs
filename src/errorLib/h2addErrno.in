#!/usr/local/bin/perl -- -*-perl-*-
#
# Copyright (c) 1992, 2003 CNRS/LAAS
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#
# $LAAS$
#

#-----------------------------------------------------------------------
#  LABORATOIRE D'AUTOMATIQUE ET D'ANALYSE DE SYSTEMES - LAAS / CNRS 
#  PROJET HILARE II - RECHERCHE DE LA LISTE DES ERREURS H2
#

#  Dec 92; Christophe Dousson, Sara Fleury;

#    Description : match les chaines de la forme:
#        1.        # define S_\w   * | \d 
#        2.        # define M_\w   * \d 
#        3.        # define M_\w   * \d \+ \d 
#    Pour le cas 1, si deux chaines identiques S_\w, teste si meme numero \d.
#    Ne conserve les erreurs S_totoTask_ERREUR que si la chaine correspondante 
#    M_totoTask a ete trouvee.

# Adjonction pour MARTHA (mh, sf):
# 
# Match les chaines de la forme:
#        #define \w (\w_REPORT << 16 | \d)    -> message d'erreur
#        #define \w_REPORT \d                 -> nom du module
#-----------------------------------------------------------------------

$robots = $ENV{'ROOTROBOTS'} ? $ENV{'ROOTROBOTS'} : "@prefix@";


if ($#ARGV < 0) {
    die("usage: h2addErrno [-init] <file1> <file2>....\n");
}

$file = "$robots/include/h2errorList.h";
$filesave  = "$robots/include/h2errorList.save.h";


#--
#-- Fichiers par defaut si option -init
#--

# $wind_base = $ENV{"WIND_BASE"};

# if (! $wind_base) {
#    die("ERROR: variable WIND_BASE undefined\n");
# } 
# if (! -d $wind_base) {
#     die("ERROR: $wind_base not a directory\n");
#}

@INITFILES = (
# Erreurs vxworks
#	      "$wind_base/target/h/*Lib.h", 
#	      "$wind_base/target/h/vwModNum.h", 
# Erreurs bibliotheques h2
	      "$robots/include/*.h",
# Erreurs modules generator
#	      "$robots/nomadic/modules/*/auto/*Error.h",
);


#--
#-- Declarations
#--

%modules=(); #- i.e. M_... (without M_)
%errors=();  #- i.e. S_....
%locus=();   #- filename and line number



#--
#-- lecture de l'ancien fichier d'erreurs (si pas d'option -init)
#--

if ($ARGV[0] eq "-init") {
    print ">> Create $file\n";
    @ARGV = ( @ARGV[1..$#ARGV], <@INITFILES> );
} else {
    print ">> Adding errors in $file\n";
    #-- lecture de l'ancien fichier des erreurs repertoriees 
    open (OLDFILE, "<".$file) || die("ERROR: Cannot open $file");
    while (<OLDFILE>) {
	if(($loc) = /^.*\/\* From\s*(.*\.h) \*\//o) {
	    $prevloc = $loc;
	}
	elsif (($err,$num)=/^\t{"(S_\w+)", (\d+)},/o) {
	    $errors{$err} = $num + 1;
	    $locus{$err} = $prevloc;
	} 
#	elsif (($src,$num,$loc)=/^\t{"M_(\w+)", (\d+),.* \/\* (.*) \*\/$/o) {
	elsif (($src,$num)=/^\t{"M_(\w+)", (\d+),.*$/o) {
	    $modules{$src} = $num;
	    $locus{$src} = $prevloc;
	}
    }
    close(OLDFILE);
    if (!%errors || !%modules) {
	die("ERROR: No errors found in $file");
    }
}

#--
#-- lecture des nouveaux fichiers d'erreurs
#--

while (<ARGV>) {	
    if (($err, $num) = /^#\s*define\s+(S_\w+).*\|\s*(\d+)/o) {
	$locus{$err} = $ARGV;
	do error_fusion($err, $num);
    } elsif (($src,$n1,$n2) = /^#\s*define\s+M_(\w+)[^\d]*(\d+) *\+ *(\d+)/o){
	$locus{$src} = $ARGV;
	do module_fusion($src, $n1+$n2);
    } elsif (($src, $num) = /^#\s*define\s+M_(\w+)[^\d]*(\d+)/o) {
	$locus{$src} = $ARGV;
        do module_fusion($src, $num);
    #-- Modules Martha
    } elsif (($src, $num) = /^#\s*define\s+(\w+)_REPORT [^\d]*(\d+)/o) {
        $locus{$src} = $ARGV;
        do module_fusion($src, $num);
    } elsif (($err, $src, $num) = /^#\s*define\s+(\w+)\s+\((\w+)_REPORT \<\< 16 \|\s*(\d+)/o) {
	$locus{"S_$src_$err"} = $ARGV;
        do error_fusion("S_$src_$err", $num);     
    }
}

if ($fatal) {
    die("   TOO MANY FATAL ERRORS...\n");
}


#--
#-- On sauve l'ancien fichier
#--
print ">> Save $file \n";
print "     in $filesave\n";
system "cp $file $filesave";


#----------------------------------------------------------------------
#--- sortie des resultats
print ">> Write $file\n";
open (MYFILE, ">$file") || die "ERROR: Cannot open file $file";
print MYFILE "/* DO NOT EDIT THIS FILE BY HAND (use h2addErrno) */\n\n"; # 


#-- 
#-- Liste des sources d'erreurs
#-- 
print MYFILE "/*\n";
print MYFILE " * List of the sources of errors\n *\n";
print MYFILE " * H2 modules errors\n";
print MYFILE " * -----------------\n";
$prevlocus = tototiti;
foreach $num (sort {$b <=> $a} values %modules) {
    if ($num < 700 && !$flagHard) {
	print MYFILE " *\n * H2 hardLib errors\n";
	print MYFILE " * -----------------\n";
	$flagHard=1;
    }
    if ($num < 600 && !$flagCom) {
	print MYFILE " *\n * H2 comLib errors\n";
	print MYFILE " * -----------------\n";
	$flagCom=1;
    }
    if ($num < 500 && !$flagSys) {
	print MYFILE " *\n * System errors\n";
	print MYFILE " * -----------------\n";
	$flagSys=1;
    }
    while (($key,$val)= each %modules) {
	if ($val == $num) {
	    if ($prevlocus ne $locus{$key}) {
		$prevlocus = $locus{$key};
		print MYFILE " * From $prevlocus:\n";
	    }
	    print MYFILE " *\t$num, $key\n";
	    break;
	}
    }
}
print MYFILE " */\n\n";


#-- generation des nouvelles tables des erreurs
#-- Cree les tableaux TOTO_TAB_FAIL regroupant les erreurs S_toto_*

print MYFILE "\n\/*\n";
print MYFILE " * Arrays of errors for each source\n";
print MYFILE " * (error name, error number)\n";
print MYFILE " *\/\n\n";
foreach (sort keys %errors) {
    #-- on extrait le nom du module du nom de l'erreur
    ($name) = /S_([^_]+)/o;

    if ($modules{$name}) {
	$name = do vxworks_rename($name);
	if ($current ne $name) {
	    if ($current) {
		#-- on termine le precedent tableau
		print MYFILE "};\n\n"
	    }
	    #-- on commence un nouveau tableau
	    $current = $name;
	    print MYFILE "static H2_FAILED_STRUCT ",$current,"_TAB_FAIL[]= {\n";
	    $prevlocus = tototiti;
	}
	#-- on ecrit la nouvelle erreur
	if ($prevlocus ne $locus{$_}) {
	    $prevlocus = $locus{$_};
	    print MYFILE " /* From $prevlocus */\n";
	}
	printf MYFILE ("\t{\"%s\", %d},", $_, $errors{$_}-1);
#	print MYFILE "\t/* $locus{$_} */";
	print MYFILE "\n";
	#-- on compte les erreurs du module
	$nberrs{$current} ++;
    }
}
#-- on termine le dernier tableau
if ($current) {
    print MYFILE "};\n\n";
}


#-- table des sources d'erreurs
#-- Cree le tableau SOURCE_TAB_FAIL de type SOURCE_FAILED_STRUCT regroupant 
#-- les sources d'erreurs (tache ou bibliotheque) M_toto

print MYFILE "\n\/*\n";
print MYFILE " * Array of the sources of errors\n";
print MYFILE " * (source name, source number, array of errors, number of errors)\n";
print MYFILE " *\/\n\n";
print MYFILE "static H2_SOURCE_FAILED_STRUCT H2_SOURCE_TAB_FAIL[] = {\n";

$prevlocus = tototiti;
foreach (sort keys %modules) {
    $num = $modules{$_};
    $name = do vxworks_rename($_);
    $nberr = $nberrs{$name};
    if ($prevlocus ne $locus{$_}) {
	$prevlocus = $locus{$_};
	print MYFILE " /* From $prevlocus */\n";
    }
    if (!$nberr) {
#	print "WARNING: no array of failures for M_$_\n";
#	print "   M_$_ defined at $locus{$_}\n";
#	print MYFILE " /* From $locus{$_} */\n";
	print MYFILE "\t{\"M_$_\", $num, ", NULL,", 0},\n";
    } else {
#	print MYFILE " /* From $locus{$_} */\n";
	print MYFILE "\t{\"M_$_\", $num, ",$name,"_TAB_FAIL, $nberr},\n";
    }
}
print MYFILE "};\n\n";


#===========================================================================
#              LES FONCTIONS LOCALES
#

sub vxworks_rename {
    local($name) = @_;
    #-- on separe les mots capitalise par un underscore
    #-- et on met tous en majuscules
    #   (ex:  piloTotoTiti --> PILO_TOTO_TITI)

    $name =~ s/([A-Z])/_\1/go;  # underscore
    $name =~ tr/a-z/A-Z/;       # majuscules
    return $name;
}

sub error_fusion {
    local($err, $num) = @_;

    $numerr = $errors{$err} - 1;
    if (($numerr != -1) && ($numerr != $num)) {
	print "   CHANGE CODE : $err: $numerr --> $num\n";
    }
    $num ++;
    ($module) = /S_([^_]+)/o;
    $found = 0;
    #-- on recherche s'il existe deja ce code d'erreur pour ce module
    foreach (%errors) {
	if (($errors{$_} == $num)) {
	  ($current_module) = /S_([^_]+)/o;
	  if ($current_module eq $module) {

	    $found = 1;
	    if ($_ ne $err) {
	      print "   CHANGE NAME : $_  \n";
	      print "            -->  $err\n";
	      print "    (definition in : $locus{$_}\n";
	      print "                 --> $locus{$err})\n";
	      undef $errors{$_};
	    }
	  }
	}
    }
    #-- enregistre le nouveau code
    if ($found == 0) {
      print "   ADD         : $err $num\n";
    }
    $errors{$err} = $num;
}

sub module_fusion {
    local ($src, $num) = @_;
    #-- On refuse 0 comme numero de module
    if ($num == 0) {return;}
    $module = $modules{$src};
    if ($module && ($module != $num)) {
	print "WARNING: In $locus{$src}:\n";
	print "   redefine code for M_$src: $module --> $num\n";
    }
    foreach (%modules) {
	if (($num == $modules{$_})&&($src ne $_)) {
	    print STDERR "ERROR: M_$_ and M_$src have same code ($num)\n";
	    print "   M_$_ is defined at $locus{$_}\n";
	    print "   M_$src is defined at $locus{$src}\n";
	    $fatal ++;
	}
    }
    $modules{$src} = $num;
}

